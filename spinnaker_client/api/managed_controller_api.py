# coding: utf-8

"""
    Spinnaker API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from spinnaker_client.api_client import ApiClient


class ManagedControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_pin_using_post(self, application, pin, **kwargs):  # noqa: E501
        """Create a pin for an artifact in an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pin_using_post(application, pin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param EnvironmentArtifactPin pin: pin (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pin_using_post_with_http_info(application, pin, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pin_using_post_with_http_info(application, pin, **kwargs)  # noqa: E501
            return data

    def create_pin_using_post_with_http_info(self, application, pin, **kwargs):  # noqa: E501
        """Create a pin for an artifact in an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pin_using_post_with_http_info(application, pin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param EnvironmentArtifactPin pin: pin (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'pin']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pin_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `create_pin_using_post`")  # noqa: E501
        # verify the required parameter 'pin' is set
        if ('pin' not in params or
                params['pin'] is None):
            raise ValueError("Missing the required parameter `pin` when calling `create_pin_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pin' in params:
            body_params = params['pin']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/pin', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_manifest_by_app_using_delete(self, application, **kwargs):  # noqa: E501
        """Delete a delivery config manifest for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_manifest_by_app_using_delete(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_manifest_by_app_using_delete_with_http_info(application, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_manifest_by_app_using_delete_with_http_info(application, **kwargs)  # noqa: E501
            return data

    def delete_manifest_by_app_using_delete_with_http_info(self, application, **kwargs):  # noqa: E501
        """Delete a delivery config manifest for an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_manifest_by_app_using_delete_with_http_info(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_manifest_by_app_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `delete_manifest_by_app_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeliveryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_manifest_using_delete(self, name, **kwargs):  # noqa: E501
        """Delete a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_manifest_using_delete(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_manifest_using_delete_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_manifest_using_delete_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_manifest_using_delete_with_http_info(self, name, **kwargs):  # noqa: E501
        """Delete a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_manifest_using_delete_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_manifest_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_manifest_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeliveryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pin_using_delete(self, application, target_environment, **kwargs):  # noqa: E501
        """Unpin one or more artifact(s) in an environment. If the `reference` parameter is specified, only the corresponding artifact will be unpinned. If it's omitted, all pinned artifacts in the environment will be unpinned.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pin_using_delete(application, target_environment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str target_environment: targetEnvironment (required)
        :param str reference: reference
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pin_using_delete_with_http_info(application, target_environment, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pin_using_delete_with_http_info(application, target_environment, **kwargs)  # noqa: E501
            return data

    def delete_pin_using_delete_with_http_info(self, application, target_environment, **kwargs):  # noqa: E501
        """Unpin one or more artifact(s) in an environment. If the `reference` parameter is specified, only the corresponding artifact will be unpinned. If it's omitted, all pinned artifacts in the environment will be unpinned.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pin_using_delete_with_http_info(application, target_environment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str target_environment: targetEnvironment (required)
        :param str reference: reference
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'target_environment', 'reference']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pin_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `delete_pin_using_delete`")  # noqa: E501
        # verify the required parameter 'target_environment' is set
        if ('target_environment' not in params or
                params['target_environment'] is None):
            raise ValueError("Missing the required parameter `target_environment` when calling `delete_pin_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501
        if 'target_environment' in params:
            path_params['targetEnvironment'] = params['target_environment']  # noqa: E501

        query_params = []
        if 'reference' in params:
            query_params.append(('reference', params['reference']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/pin/{targetEnvironment}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_veto_using_delete(self, application, reference, target_environment, version, **kwargs):  # noqa: E501
        """Remove veto of an artifact version in an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_veto_using_delete(application, reference, target_environment, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str reference: reference (required)
        :param str target_environment: targetEnvironment (required)
        :param str version: version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_veto_using_delete_with_http_info(application, reference, target_environment, version, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_veto_using_delete_with_http_info(application, reference, target_environment, version, **kwargs)  # noqa: E501
            return data

    def delete_veto_using_delete_with_http_info(self, application, reference, target_environment, version, **kwargs):  # noqa: E501
        """Remove veto of an artifact version in an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_veto_using_delete_with_http_info(application, reference, target_environment, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str reference: reference (required)
        :param str target_environment: targetEnvironment (required)
        :param str version: version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'reference', 'target_environment', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_veto_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `delete_veto_using_delete`")  # noqa: E501
        # verify the required parameter 'reference' is set
        if ('reference' not in params or
                params['reference'] is None):
            raise ValueError("Missing the required parameter `reference` when calling `delete_veto_using_delete`")  # noqa: E501
        # verify the required parameter 'target_environment' is set
        if ('target_environment' not in params or
                params['target_environment'] is None):
            raise ValueError("Missing the required parameter `target_environment` when calling `delete_veto_using_delete`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `delete_veto_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501
        if 'reference' in params:
            path_params['reference'] = params['reference']  # noqa: E501
        if 'target_environment' in params:
            path_params['targetEnvironment'] = params['target_environment']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/veto/{targetEnvironment}/{reference}/{version}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def diff_manifest_using_post(self, manifest, **kwargs):  # noqa: E501
        """Ad-hoc validate and diff a config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.diff_manifest_using_post(manifest, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeliveryConfig manifest: manifest (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.diff_manifest_using_post_with_http_info(manifest, **kwargs)  # noqa: E501
        else:
            (data) = self.diff_manifest_using_post_with_http_info(manifest, **kwargs)  # noqa: E501
            return data

    def diff_manifest_using_post_with_http_info(self, manifest, **kwargs):  # noqa: E501
        """Ad-hoc validate and diff a config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.diff_manifest_using_post_with_http_info(manifest, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeliveryConfig manifest: manifest (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manifest']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method diff_manifest_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'manifest' is set
        if ('manifest' not in params or
                params['manifest'] is None):
            raise ValueError("Missing the required parameter `manifest` when calling `diff_manifest_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'manifest' in params:
            body_params = params['manifest']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-yaml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs/diff', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def diff_resource_using_post(self, resource, **kwargs):  # noqa: E501
        """Ad-hoc validate and diff a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.diff_resource_using_post(resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Resource resource: resource (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.diff_resource_using_post_with_http_info(resource, **kwargs)  # noqa: E501
        else:
            (data) = self.diff_resource_using_post_with_http_info(resource, **kwargs)  # noqa: E501
            return data

    def diff_resource_using_post_with_http_info(self, resource, **kwargs):  # noqa: E501
        """Ad-hoc validate and diff a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.diff_resource_using_post_with_http_info(resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Resource resource: resource (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method diff_resource_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource' is set
        if ('resource' not in params or
                params['resource'] is None):
            raise ValueError("Missing the required parameter `resource` when calling `diff_resource_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resource' in params:
            body_params = params['resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-yaml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/diff', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_resource_using_get(self, account, cloud_provider, cluster_name, **kwargs):  # noqa: E501
        """Generates an artifact definition based on the artifact used in a running cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_resource_using_get(account, cloud_provider, cluster_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: account (required)
        :param str cloud_provider: cloudProvider (required)
        :param str cluster_name: clusterName (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_resource_using_get_with_http_info(account, cloud_provider, cluster_name, **kwargs)  # noqa: E501
        else:
            (data) = self.export_resource_using_get_with_http_info(account, cloud_provider, cluster_name, **kwargs)  # noqa: E501
            return data

    def export_resource_using_get_with_http_info(self, account, cloud_provider, cluster_name, **kwargs):  # noqa: E501
        """Generates an artifact definition based on the artifact used in a running cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_resource_using_get_with_http_info(account, cloud_provider, cluster_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: account (required)
        :param str cloud_provider: cloudProvider (required)
        :param str cluster_name: clusterName (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account', 'cloud_provider', 'cluster_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_resource_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account' is set
        if ('account' not in params or
                params['account'] is None):
            raise ValueError("Missing the required parameter `account` when calling `export_resource_using_get`")  # noqa: E501
        # verify the required parameter 'cloud_provider' is set
        if ('cloud_provider' not in params or
                params['cloud_provider'] is None):
            raise ValueError("Missing the required parameter `cloud_provider` when calling `export_resource_using_get`")  # noqa: E501
        # verify the required parameter 'cluster_name' is set
        if ('cluster_name' not in params or
                params['cluster_name'] is None):
            raise ValueError("Missing the required parameter `cluster_name` when calling `export_resource_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account' in params:
            path_params['account'] = params['account']  # noqa: E501
        if 'cloud_provider' in params:
            path_params['cloudProvider'] = params['cloud_provider']  # noqa: E501
        if 'cluster_name' in params:
            path_params['clusterName'] = params['cluster_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/export/artifact/{cloudProvider}/{account}/{clusterName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_resource_using_get1(self, account, cloud_provider, name, service_account, type, **kwargs):  # noqa: E501
        """Generate a keel resource definition for a deployed cloud resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_resource_using_get1(account, cloud_provider, name, service_account, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: account (required)
        :param str cloud_provider: cloudProvider (required)
        :param str name: name (required)
        :param str service_account: serviceAccount (required)
        :param str type: type (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_resource_using_get1_with_http_info(account, cloud_provider, name, service_account, type, **kwargs)  # noqa: E501
        else:
            (data) = self.export_resource_using_get1_with_http_info(account, cloud_provider, name, service_account, type, **kwargs)  # noqa: E501
            return data

    def export_resource_using_get1_with_http_info(self, account, cloud_provider, name, service_account, type, **kwargs):  # noqa: E501
        """Generate a keel resource definition for a deployed cloud resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_resource_using_get1_with_http_info(account, cloud_provider, name, service_account, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account: account (required)
        :param str cloud_provider: cloudProvider (required)
        :param str name: name (required)
        :param str service_account: serviceAccount (required)
        :param str type: type (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account', 'cloud_provider', 'name', 'service_account', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_resource_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account' is set
        if ('account' not in params or
                params['account'] is None):
            raise ValueError("Missing the required parameter `account` when calling `export_resource_using_get1`")  # noqa: E501
        # verify the required parameter 'cloud_provider' is set
        if ('cloud_provider' not in params or
                params['cloud_provider'] is None):
            raise ValueError("Missing the required parameter `cloud_provider` when calling `export_resource_using_get1`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `export_resource_using_get1`")  # noqa: E501
        # verify the required parameter 'service_account' is set
        if ('service_account' not in params or
                params['service_account'] is None):
            raise ValueError("Missing the required parameter `service_account` when calling `export_resource_using_get1`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `export_resource_using_get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account' in params:
            path_params['account'] = params['account']  # noqa: E501
        if 'cloud_provider' in params:
            path_params['cloudProvider'] = params['cloud_provider']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []
        if 'service_account' in params:
            query_params.append(('serviceAccount', params['service_account']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/export/{cloudProvider}/{account}/{type}/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_details_using_get(self, application, **kwargs):  # noqa: E501
        """Get managed details about an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_details_using_get(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param list[str] entities: entities
        :param bool include_details: includeDetails
        :param int max_artifact_versions: maxArtifactVersions
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_details_using_get_with_http_info(application, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_details_using_get_with_http_info(application, **kwargs)  # noqa: E501
            return data

    def get_application_details_using_get_with_http_info(self, application, **kwargs):  # noqa: E501
        """Get managed details about an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_details_using_get_with_http_info(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param list[str] entities: entities
        :param bool include_details: includeDetails
        :param int max_artifact_versions: maxArtifactVersions
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'entities', 'include_details', 'max_artifact_versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_details_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `get_application_details_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501

        query_params = []
        if 'entities' in params:
            query_params.append(('entities', params['entities']))  # noqa: E501
            collection_formats['entities'] = 'multi'  # noqa: E501
        if 'include_details' in params:
            query_params.append(('includeDetails', params['include_details']))  # noqa: E501
        if 'max_artifact_versions' in params:
            query_params.append(('maxArtifactVersions', params['max_artifact_versions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_by_using_get(self, application, **kwargs):  # noqa: E501
        """Get the delivery config associated with an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_by_using_get(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_by_using_get_with_http_info(application, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_by_using_get_with_http_info(application, **kwargs)  # noqa: E501
            return data

    def get_config_by_using_get_with_http_info(self, application, **kwargs):  # noqa: E501
        """Get the delivery config associated with an application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_by_using_get_with_http_info(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_by_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `get_config_by_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeliveryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_constraint_state_using_get(self, application, environment, **kwargs):  # noqa: E501
        """List up-to {limit} current constraint states for an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_constraint_state_using_get(application, environment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str environment: environment (required)
        :param str limit: limit
        :return: ConstraintState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_constraint_state_using_get_with_http_info(application, environment, **kwargs)  # noqa: E501
        else:
            (data) = self.get_constraint_state_using_get_with_http_info(application, environment, **kwargs)  # noqa: E501
            return data

    def get_constraint_state_using_get_with_http_info(self, application, environment, **kwargs):  # noqa: E501
        """List up-to {limit} current constraint states for an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_constraint_state_using_get_with_http_info(application, environment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str environment: environment (required)
        :param str limit: limit
        :return: ConstraintState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'environment', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_constraint_state_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `get_constraint_state_using_get`")  # noqa: E501
        # verify the required parameter 'environment' is set
        if ('environment' not in params or
                params['environment'] is None):
            raise ValueError("Missing the required parameter `environment` when calling `get_constraint_state_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501
        if 'environment' in params:
            path_params['environment'] = params['environment']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/environment/{environment}/constraints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstraintState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manifest_artifacts_using_get(self, name, **kwargs):  # noqa: E501
        """Get the status of each version of each artifact in each environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manifest_artifacts_using_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_manifest_artifacts_using_get_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_manifest_artifacts_using_get_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_manifest_artifacts_using_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get the status of each version of each artifact in each environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manifest_artifacts_using_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manifest_artifacts_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_manifest_artifacts_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs/{name}/artifacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manifest_using_get(self, name, **kwargs):  # noqa: E501
        """Get a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manifest_using_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_manifest_using_get_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_manifest_using_get_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_manifest_using_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manifest_using_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manifest_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_manifest_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeliveryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manifest_yaml_using_get(self, name, **kwargs):  # noqa: E501
        """Get a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manifest_yaml_using_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_manifest_yaml_using_get_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_manifest_yaml_using_get_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_manifest_yaml_using_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manifest_yaml_using_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manifest_yaml_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_manifest_yaml_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/x-yaml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs/{name}.yml', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeliveryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_status_using_get(self, resource_id, **kwargs):  # noqa: E501
        """Get status of a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_status_using_get(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_resource_status_using_get_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_status_using_get_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def get_resource_status_using_get_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Get status of a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_status_using_get_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_status_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `get_resource_status_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/{resourceId}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_using_get(self, resource_id, **kwargs):  # noqa: E501
        """Get a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_using_get(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_resource_using_get_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_using_get_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def get_resource_using_get_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Get a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_using_get_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `get_resource_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_yaml_using_get(self, resource_id, **kwargs):  # noqa: E501
        """Get a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_yaml_using_get(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_resource_yaml_using_get_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_yaml_using_get_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def get_resource_yaml_using_get_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Get a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_yaml_using_get_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_yaml_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `get_resource_yaml_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/x-yaml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/{resourceId}.yml', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_application_using_post(self, application, **kwargs):  # noqa: E501
        """Pause management of an entire application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_application_using_post(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pause_application_using_post_with_http_info(application, **kwargs)  # noqa: E501
        else:
            (data) = self.pause_application_using_post_with_http_info(application, **kwargs)  # noqa: E501
            return data

    def pause_application_using_post_with_http_info(self, application, **kwargs):  # noqa: E501
        """Pause management of an entire application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_application_using_post_with_http_info(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_application_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `pause_application_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/pause', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_resource_using_post(self, resource_id, **kwargs):  # noqa: E501
        """Pause management of a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_resource_using_post(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pause_resource_using_post_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.pause_resource_using_post_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def pause_resource_using_post_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Pause management of a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_resource_using_post_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_resource_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `pause_resource_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/{resourceId}/pause', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resume_application_using_delete(self, application, **kwargs):  # noqa: E501
        """Resume management of an entire application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_application_using_delete(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resume_application_using_delete_with_http_info(application, **kwargs)  # noqa: E501
        else:
            (data) = self.resume_application_using_delete_with_http_info(application, **kwargs)  # noqa: E501
            return data

    def resume_application_using_delete_with_http_info(self, application, **kwargs):  # noqa: E501
        """Resume management of an entire application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_application_using_delete_with_http_info(application, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_application_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `resume_application_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/pause', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resume_resource_using_delete(self, resource_id, **kwargs):  # noqa: E501
        """Resume management of a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_resource_using_delete(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resume_resource_using_delete_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resume_resource_using_delete_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def resume_resource_using_delete_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Resume management of a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_resource_using_delete_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str resource_id: resourceId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_resource_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `resume_resource_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/resources/{resourceId}/pause', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schema_using_get(self, **kwargs):  # noqa: E501
        """Ad-hoc validate and diff a config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schema_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.schema_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.schema_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def schema_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Ad-hoc validate and diff a config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schema_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schema_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/x-yaml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs/schema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_constraint_status_using_post(self, application, environment, status, **kwargs):  # noqa: E501
        """Update the status of an environment constraint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_constraint_status_using_post(application, environment, status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str environment: environment (required)
        :param ConstraintStatus status: status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_constraint_status_using_post_with_http_info(application, environment, status, **kwargs)  # noqa: E501
        else:
            (data) = self.update_constraint_status_using_post_with_http_info(application, environment, status, **kwargs)  # noqa: E501
            return data

    def update_constraint_status_using_post_with_http_info(self, application, environment, status, **kwargs):  # noqa: E501
        """Update the status of an environment constraint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_constraint_status_using_post_with_http_info(application, environment, status, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param str environment: environment (required)
        :param ConstraintStatus status: status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'environment', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_constraint_status_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `update_constraint_status_using_post`")  # noqa: E501
        # verify the required parameter 'environment' is set
        if ('environment' not in params or
                params['environment'] is None):
            raise ValueError("Missing the required parameter `environment` when calling `update_constraint_status_using_post`")  # noqa: E501
        # verify the required parameter 'status' is set
        if ('status' not in params or
                params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `update_constraint_status_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501
        if 'environment' in params:
            path_params['environment'] = params['environment']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'status' in params:
            body_params = params['status']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/environment/{environment}/constraint', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_manifest_using_post(self, manifest, **kwargs):  # noqa: E501
        """Create or update a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_manifest_using_post(manifest, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeliveryConfig manifest: manifest (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upsert_manifest_using_post_with_http_info(manifest, **kwargs)  # noqa: E501
        else:
            (data) = self.upsert_manifest_using_post_with_http_info(manifest, **kwargs)  # noqa: E501
            return data

    def upsert_manifest_using_post_with_http_info(self, manifest, **kwargs):  # noqa: E501
        """Create or update a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_manifest_using_post_with_http_info(manifest, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeliveryConfig manifest: manifest (required)
        :return: DeliveryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manifest']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_manifest_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'manifest' is set
        if ('manifest' not in params or
                params['manifest'] is None):
            raise ValueError("Missing the required parameter `manifest` when calling `upsert_manifest_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'manifest' in params:
            body_params = params['manifest']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-yaml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeliveryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_manifest_using_post(self, manifest, **kwargs):  # noqa: E501
        """Validate a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_manifest_using_post(manifest, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeliveryConfig manifest: manifest (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_manifest_using_post_with_http_info(manifest, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_manifest_using_post_with_http_info(manifest, **kwargs)  # noqa: E501
            return data

    def validate_manifest_using_post_with_http_info(self, manifest, **kwargs):  # noqa: E501
        """Validate a delivery config manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_manifest_using_post_with_http_info(manifest, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeliveryConfig manifest: manifest (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manifest']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_manifest_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'manifest' is set
        if ('manifest' not in params or
                params['manifest'] is None):
            raise ValueError("Missing the required parameter `manifest` when calling `validate_manifest_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'manifest' in params:
            body_params = params['manifest']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/x-yaml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-yaml'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/delivery-configs/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def veto_using_post(self, application, veto, **kwargs):  # noqa: E501
        """Veto an artifact version in an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.veto_using_post(application, veto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param EnvironmentArtifactVeto veto: veto (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.veto_using_post_with_http_info(application, veto, **kwargs)  # noqa: E501
        else:
            (data) = self.veto_using_post_with_http_info(application, veto, **kwargs)  # noqa: E501
            return data

    def veto_using_post_with_http_info(self, application, veto, **kwargs):  # noqa: E501
        """Veto an artifact version in an environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.veto_using_post_with_http_info(application, veto, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: application (required)
        :param EnvironmentArtifactVeto veto: veto (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'veto']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method veto_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application' is set
        if ('application' not in params or
                params['application'] is None):
            raise ValueError("Missing the required parameter `application` when calling `veto_using_post`")  # noqa: E501
        # verify the required parameter 'veto' is set
        if ('veto' not in params or
                params['veto'] is None):
            raise ValueError("Missing the required parameter `veto` when calling `veto_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application' in params:
            path_params['application'] = params['application']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'veto' in params:
            body_params = params['veto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/managed/application/{application}/veto', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
